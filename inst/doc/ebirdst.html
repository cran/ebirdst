<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Matt Strimas-Mackey, Tom Auer, Daniel Fink" />

<meta name="date" content="2022-07-07" />

<title>Introduction to eBird Status &amp; Trends Data</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to eBird Status &amp; Trends
Data</h1>
<h4 class="author">Matt Strimas-Mackey, Tom Auer, Daniel Fink</h4>
<h4 class="date">2022-07-07</h4>



<style type="text/css">
.table {
    width: 75%;
}
</style>
<div id="outline" class="section level1">
<h1>Outline</h1>
<ol style="list-style-type: decimal">
<li><a href="#background">Background</a></li>
<li><a href="#access">Data access</a></li>
<li><a href="#species">Species list</a></li>
<li><a href="#types">Data types and structure</a></li>
</ol>
</div>
<div id="background" class="section level1">
<h1>Background</h1>
<p>The study and conservation of the natural world relies on detailed
information about the distributions, abundances, environmental
associations, and population trends of species over time. For many taxa,
this information is challenging to obtain at relevant geographic scales.
The goal of the eBird Status and Trends project is to use data from <a href="https://ebird.org/home">eBird</a>, the global community science
bird monitoring program administered by The Cornell Lab of Ornithology,
to generate a reliable, standardized source of biodiversity information
for the world’s bird populations. To translate the eBird observations
into robust data products, we use machine learning to fill
spatiotemporal gaps, using local land cover descriptions derived from
NASA MODIS and other remote sensing data, while controlling for biases
inherent in species observations collected by community scientists.</p>
<p>This data set provides estimates of the full annual cycle
distributions, abundances, and environmental associations for
<code>r</code>scales::comma(nrow(ebirdst::ebirdst_runs))` species for
the year 2020. For each species, distribution and abundance estimates
are available for all 52 weeks of the year across a regular grid of
locations that cover the globe at a resolution of 2.96 km X 2.96 km.
Variation in detectability associated with the search effort is
controlled by standardizing the estimates as the expected occurrence
rate and count of the species on a 1 hour, 1 km checklist by an expert
eBird observer at the optimal time of day for detecting the species.</p>
<p>To describe how each species is associated with features of its local
environment, estimates of the relative importance of each remotely
sensed variable (e.g. land cover, elevation, etc), are available
throughout the year at a monthly temporal and regional spatial
resolution. Additionally, to assess estimate quality, we provide upper
and lower confidence bounds for abundance estimates and
regional-seasonal scale validation metrics for the underlying
statistical models. For more information about the data products see the
<a href="https://ebird.org/science/status-and-trends/faq">FAQ and
summaries</a>. See Fink et al. (2019) for more information about the
analysis used to generate these data.</p>
</div>
<div id="access" class="section level1">
<h1>Data access</h1>
<p>Data access is granted through an Access Request Form at: <a href="https://ebird.org/st/request" class="uri">https://ebird.org/st/request</a>. Access with this form
generates a key to be used with this R package and is provided
immediately (as long as commercial use is not requested). Our terms of
use have been designed to be quite permissive in many cases,
particularly academic and research use. When requesting data access,
please be sure to carefully read the terms of use and ensure that your
intended use is not restricted.</p>
<p>After completing the Access Request Form, you will be provided a
Status and Trends access key, which you will need when downloading data.
To store the key so the package can access it when downloading data, use
the function <code>set_ebirdst_access_key(&quot;XXXXX&quot;)</code>, where
<code>&quot;XXXXX&quot;</code> is the access key provided to you. <strong>Restart
R after setting the access key.</strong></p>
<p>Throughout the package vignettes, a simplified example dataset is
used consisting of Yellow-bellied Sapsucker in Michigan. This dataset is
designed to be small for faster download and is accessible without a
key. The following will download the example dataset to you
computer:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ebirdst)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(raster)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># download a simplified example dataset for Yellow-bellied Sapsucker in Michigan</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>path <span class="ot">&lt;-</span> <span class="fu">ebirdst_download</span>(<span class="at">species =</span> <span class="st">&quot;example_data&quot;</span>)</span></code></pre></div>
<p>By default, <code>ebirdst_download()</code> downloads data to a
sensible persistent directory on your computer. You can see what that
directory is with the function <code>ebirdst_data_dir()</code>. You can
change the default download location to a directory of your choosing by
setting the environment variable <code>EBIRDST_DATA_DIR</code>, for
example by calling <code>usethis::edit_r_environ()</code> and adding a
line such as
<code>EBIRDST_DATA_DIR=/custom/download/directory/</code>.</p>
<p>To download the data package for a species, provide the species code,
English common name, or scientific name to
<code>ebirdst_download()</code>. Note that data for all other species
requires an API key to access. <strong>IMPORTANT: after downloading a
data package, do not change the file structure or rename files. Doing so
will prevent you from being able to work with the data in
R.</strong></p>
</div>
<div id="species" class="section level1">
<h1>Species list</h1>
<p>The full list of the species with data available for download is
available in the data frame <code>ebirdst_runs</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">glimpse</span>(ebirdst_runs)</span></code></pre></div>
<p>which is included in this package. If you’re working in RStudio, you
can use <code>View()</code> to interactively explore this data frame.
You can also consult the <a href="https://science.ebird.org/en/status-and-trends/">Status and Trends
landing page</a> to see the full list of species.</p>
<p>All species go through a process of expert human review prior to
being released. The <code>ebirdst_runs</code> data frame also contains
information from this review process. Reviewers assess each of the four
seasons: breeding, non-breeding, pre-breeding migration, and
post-breeding migration. Resident (i.e., non-migratory) species are
identified by having <code>TRUE</code> in the <code>resident</code>
column of <code>ebirdst_runs</code>, and these species are assessed
across the whole year rather than seasonally. <code>ebirdst_runs</code>
contains two important pieces of information for each season: a
<strong>quality</strong> rating and <strong>seasonal dates</strong>.</p>
<p>The <strong>seasonal dates</strong> define the weeks that fall within
each season. Breeding and non-breeding season dates are defined for each
species as the weeks during those seasons when the species’ population
does not move. For this reason, these seasons are also described as
stationary periods. Migration periods are defined as the periods of
movement between the stationary non-breeding and breeding seasons. Note
that for many species these migratory periods include not only movement
from breeding grounds to non-breeding grounds, but also post-breeding
dispersal, molt migration, and other movements.</p>
<p>Reviewers also examine the model estimates for each season to assess
the amount of extrapolation or omission present in the model, and assign
an associated quality rating ranging from 0 (lowest quality) to 3
(highest quality). Extrapolation refers to cases where the model
predicts occurrence where the species is known to be absent, while
omission refers to the model failing to predict occurrence where a
species is known to be present.</p>
<p>A rating of 0 implies this season failed review and model results
should not be used at all for this period. Ratings of 1-3 correspond to
a gradient of more to less extrapolation and/or omission, and we often
use a traffic light analogy when referring to them:</p>
<ol style="list-style-type: decimal">
<li><strong>Red light</strong>: low quality, extensive extrapolation
and/or omission and noise, but at least some regions have estimates that
are accurate; can be used with caution in certain regions.</li>
<li><strong>Yellow light</strong>: medium quality, some extrapolation
and/or omission; use with caution.</li>
<li><strong>Green light</strong>: high quality, very little or no
extrapolation and/or omission; these seasons can be safely used.</li>
</ol>
</div>
<div id="types" class="section level1">
<h1>Data types and structure</h1>
<p>eBird Status and Trends data packages are identified by the 6-letter
eBird species code (e.g. <code>yepsap</code> for Yellow-bellied
Sapsucker) and the Status and Trends estimation year (2020 for this
version of the R package). They are stored within sub-directories that
correspond to these variables, and you can get the path to this
directory with:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for non-example data use the species code or name instead of &quot;example_data&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>path <span class="ot">&lt;-</span> <span class="fu">get_species_path</span>(<span class="st">&quot;example_data&quot;</span>)</span></code></pre></div>
<p>Within this data package directory, the following files and
directories will be present:</p>
<ul>
<li><code>weekly/</code>: a directory containing weekly estimates of
occurrence, count, relative abundance, and percent of population on a
regular grid in GeoTIFF format at three resolutions. See below for more
details.</li>
<li><code>seasonal/</code>: a directory containing seasonal estimates of
occurrence, count, relative abundance, and percent of population on a
regular grid in GeoTIFF format at three resolutions. These are derived
from the corresponding weekly raster data. Dates defining the boundary
of each season are set on a species-specific basis by an expert reviewer
familiar with the species. These dates are available in the
<code>ebirdst_runs</code> data frame. Only seasons that passed the
expert review process are included. See below for more details.</li>
<li><code>ranges/</code>: a directory containing GeoPackages storing
range boundary polygons. See below for more details.</li>
<li><code>stixel_summary.db</code>: an SQLite database containing
information on habitat associations, including predictor importance (PI)
and partial dependence (PD) estimates.</li>
<li><code>predictions.db</code>: model predictions for a test dataset
held out of the model fitting. These predictions are used for
calculating predictive performance metrics (PPMs) using the
<code>ebirdst_ppms()</code> function.</li>
<li><code>config.json</code>: run-specific parameters, mostly for
internal use, but also containing useful parameters for mapping the
abundance data. These parameters can be loaded with
<code>load_fac_map_parameters()</code>.</li>
</ul>
<p>The vignette will cover the raster and range data.</p>
<div id="weekly-raster-estimates" class="section level2">
<h2>Weekly raster estimates</h2>
<p>The core raster data products are the weekly estimates of occurrence,
count, relative abundance, and percent of population. These are all
stored in the widely used GeoTIFF raster format, and we refer to them as
“weekly cubes” (e.g. the “weekly abundance cube”). All cubes have 52
weeks and cover the entire globe, even for species with ranges only
covering a small region. They come with areas of predicted and assumed
zeroes, such that any cells that are <code>NA</code> represent areas
where we didn’t produce model estimates.</p>
<p>All estimates are the median expected value for a 1km, 1 hour eBird
Traveling Count by an expert eBird observer at the optimal time of day
and for optimal weather conditions to observe the given species.</p>
<ul>
<li><strong>Occurrence</strong> <code>occurrence</code>: the expected
probability of encountering a species.</li>
<li><strong>Count</strong> <code>count</code>: the expected count of a
species, conditional on its occurrence at the given location.</li>
<li><strong>Relative abundance</strong> <code>abundance</code>: the
expected relative abundance of a species, computed as the product of the
probability of occurrence and the count conditional on occurrence. In
addition to the median relative abundance, upper and lower confidence
intervals (CIs) are provided, defined at the 10th and 90th quantile of
relative abundance, respectively.</li>
<li><strong>Percent of population</strong>
<code>precent-population</code>: the percent of the total relative
abundance within each cell. This is a derived product calculated by
dividing each cell value in the relative abundance raster by the sum of
all cell values</li>
</ul>
<p>All predictions are made on a standard 2.96 x 2.96 km global grid,
however, for convenience lower resolution GeoTIFFs are also provided,
which are typically much faster to work with. However, note that to keep
file sizes small, <strong>the example dataset only contains low
resolution data</strong>. The three resolutions are:</p>
<ul>
<li>High resolution (<code>hr</code>): the native 2.96 km resolution
data</li>
<li>Medium resolution (<code>mr</code>): the <code>hr</code> data
aggregated by a factor of 3 in each direction resulting in a resolution
of 8.89 km</li>
<li>Low resolution (<code>lr</code>): the <code>hr</code> data
aggregated by a factor of 9 in each direction resulting in a resolution
of 26.7 km</li>
</ul>
<p>The weekly cubes use the following naming convention:</p>
<p><code>weekly/&lt;species_code&gt;_&lt;product&gt;_&lt;metric&gt;_&lt;resolution&gt;_&lt;year&gt;.tif</code></p>
<p>where <code>metric</code> is typically <code>median</code>, except
for the relative abundance CIs, which use <code>lower</code> and
<code>upper</code>. The function <code>load_raster()</code> is used to
load these data into R and takes arguments for <code>product</code>,
<code>metric</code> and <code>resolution</code>. For example,</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># weekly, low res, median occurrence</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>occ_lr <span class="ot">&lt;-</span> <span class="fu">load_raster</span>(path, <span class="at">product =</span> <span class="st">&quot;occurrence&quot;</span>, <span class="at">resolution =</span> <span class="st">&quot;lr&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>occ_lr</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># use parse_raster_dates() to get the date associated which each raster layer</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="fu">parse_raster_dates</span>(occ_lr)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># weekly, low res, abundance confidence intervals</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>abd_lower <span class="ot">&lt;-</span> <span class="fu">load_raster</span>(path, <span class="at">product =</span> <span class="st">&quot;abundance&quot;</span>, <span class="at">metric =</span> <span class="st">&quot;lower&quot;</span>, </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                         <span class="at">resolution =</span> <span class="st">&quot;lr&quot;</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>abd_upper <span class="ot">&lt;-</span> <span class="fu">load_raster</span>(path, <span class="at">product =</span> <span class="st">&quot;abundance&quot;</span>, <span class="at">metric =</span> <span class="st">&quot;upper&quot;</span>, </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                         <span class="at">resolution =</span> <span class="st">&quot;lr&quot;</span>)</span></code></pre></div>
<p>The GeoTIFFs use the same Sinusoidal projection as NASA MODIS data.
This projection is ideal for analysis, as it is an equal are projection,
but is not ideal for mapping since it introduces significant
distortion.</p>
</div>
<div id="seasonal-raster-estimates" class="section level2">
<h2>Seasonal raster estimates</h2>
<p>The seasonal raster estimates are provided for the same set of
products and at the same three resolutions as the weekly estimates.
They’re derived from the weekly data by taking the cell-wise mean or max
across the weeks within each season. The seasonal boundary dates are
defined through a process of expert review of each species, and are
available in the data frame <code>ebirdst_runs</code>. Each season is
also given a quality score from 0 (fail) to 3 (high quality), and
seasons with a score of 0 are not provided.</p>
<p>The seasonal GeoTIFFs use the following naming convention:</p>
<p><code>seasonal/&lt;species_code&gt;_&lt;product&gt;_seasonal_&lt;metric&gt;_&lt;resolution&gt;_&lt;year&gt;.tif</code></p>
<p>where <code>metric</code> is either <code>mean</code> or
<code>max</code>. The function
<code>load_raster(period = &quot;seasonal&quot;)</code> is used to load these data
into R and takes arguments for <code>product</code>, <code>metric</code>
and <code>resolution</code>. For example,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seasonal, low res, mean relative abundance</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>abd_seasonal_mean <span class="ot">&lt;-</span> <span class="fu">load_raster</span>(path, <span class="at">product =</span> <span class="st">&quot;abundance&quot;</span>, </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">period =</span> <span class="st">&quot;seasonal&quot;</span>, <span class="at">metric =</span> <span class="st">&quot;mean&quot;</span>, </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">resolution =</span> <span class="st">&quot;lr&quot;</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># season that each layer corresponds to</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(abd_seasonal_mean)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># just the breeding season layer</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>abd_seasonal_mean[[<span class="st">&quot;breeding&quot;</span>]]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># seasonal, low res, max occurrence</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>occ_seasonal_max <span class="ot">&lt;-</span> <span class="fu">load_raster</span>(path, <span class="at">product =</span> <span class="st">&quot;occurrence&quot;</span>, </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                                <span class="at">period =</span> <span class="st">&quot;seasonal&quot;</span>, <span class="at">metric =</span> <span class="st">&quot;max&quot;</span>, </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                                <span class="at">resolution =</span> <span class="st">&quot;lr&quot;</span>)</span></code></pre></div>
<p>Finally, as a convenience, the data products include year-round
rasters summarizing the mean or max across all weeks that fall within a
season that passed the expert review process. These can be accessed
similarly to the seasonal products, just with
<code>period = &quot;full-year&quot;</code> instead. For example, these can layers
be used in conservation planning to assess the most important sites
across the full range and full annual cycle of a species.</p>
<pre class="rtypes_fullyear"><code># full year, low res, maximum relative abundance
abd_fy_max &lt;- load_raster(path, product = &quot;abundance&quot;, 
                           period = &quot;full-year&quot;, metric = &quot;max&quot;, 
                           resolution = &quot;lr&quot;)</code></pre>
</div>
<div id="range-boundaries" class="section level2">
<h2>Range boundaries</h2>
<p>Seasonal range polygons are defined as the boundaries of non-zero
seasonal relative abundance estimates, which are then (optionally)
smoothed to produce more aesthetically pleasing polygons using the
<code>smoothr</code> package. They are provided in the widely used
GeoPackage format, with file naming convention:</p>
<p><code>ranges/&lt;species_code&gt;_range_seasonal_&lt;raw/smooth&gt;_&lt;resolution&gt;_&lt;year&gt;.gpkg</code></p>
<p>where <code>raw</code> refers to the polygons derived directly from
the raster data and <code>smooth</code> refers to the smoothed polygons.
Note that only low and medium resolution ranges are provided. These
range polygons can be loaded with <code>load_ranges()</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># seasonal, low res, smoothed ranges</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>ranges <span class="ot">&lt;-</span> <span class="fu">load_ranges</span>(path, <span class="at">resolution =</span> <span class="st">&quot;lr&quot;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>ranges</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># subset to just the breeding season range using dplyr</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>range_breeding <span class="ot">&lt;-</span> <span class="fu">filter</span>(ranges, season <span class="sc">==</span> <span class="st">&quot;breeding&quot;</span>)</span></code></pre></div>
</div>
<div id="habitat-association-and-ppm-data" class="section level2">
<h2>Habitat association and PPM data</h2>
<p>The two SQLite database contained within the species data package,
provide tabular data with information about modeled relationships
between observations and the ecological covariates, as well as data that
can be used to assess predictive performance. Note that these SQLite
databases are quite large (many GBs in size) and are therefore note
downloaded by default. To access these tabular data, you must use the
parameter <code>tifs_only = FALSE</code> in the
<code>ebirdst_download()</code> function.</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>Fink, D., T. Auer, A. Johnston, V. Ruiz‐Gutierrez, W.M. Hochachka, S.
Kelling. 2019. Modeling avian full annual cycle distribution and
population trends with citizen science data. Ecological Applications,
00(00):e02056. <a href="https://doi.org/10.1002/eap.2056" class="uri">https://doi.org/10.1002/eap.2056</a></p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
